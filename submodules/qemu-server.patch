diff --git a/src/PVE/QemuServer.pm b/src/PVE/QemuServer.pm
index ddd30abb..9253056a 100644
--- a/src/PVE/QemuServer.pm
+++ b/src/PVE/QemuServer.pm
@@ -165,7 +165,7 @@ my $vga_fmt = {
         optional => 1,
         default_key => 1,
         enum => [
-            qw(cirrus qxl qxl2 qxl3 qxl4 none serial0 serial1 serial2 serial3 std virtio virtio-gl vmware)
+            qw(cirrus qxl qxl2 qxl3 qxl4 none serial0 serial1 serial2 serial3 std virtio virtio-gl vmware tcx cg3)
         ],
     },
     memory => {
@@ -204,16 +204,30 @@ my $ivshmem_fmt = {
 my $audio_fmt = {
     device => {
         type => 'string',
-        enum => [qw(ich9-intel-hda intel-hda AC97)],
+        enum => [qw(ich9-intel-hda intel-hda AC97 sb16 adlib pcspk sb16-adlib-pcspk)],
         description => "Configure an audio device.",
     },
     driver => {
         type => 'string',
-        enum => ['spice', 'none'],
+        enum => ['spice', 'none', 'alsa', 'pa', 'pipewire'],
         default => 'spice',
         optional => 1,
         description => "Driver backend for the audio device.",
     },
+	server =>  {
+        type => 'string',
+        pattern => '^(([^:/?#]+):)?(//([^/?#]*))?([^?#]*)(\?([^#]*))?(#(.*))?',
+        default => '',
+        optional => 1,
+        description => "Local or network address of the X server",
+        format_description => 'uri://host:display'
+    },
+    mesa => {
+        type => 'boolean',
+        optional => 1,
+        default => '0',
+        description =>  "Enable 3dfx/mesa passthrough. This is only useful for Windows 9X/XP guests.",
+    },
 };
 
 my $spice_enhancements_fmt = {
@@ -659,7 +673,7 @@ EODESCR
     bios => {
         optional => 1,
         type => 'string',
-        enum => [qw(seabios ovmf)],
+        enum => [qw(seabios ovmf openbios-sparc32 openbios-sparc64 ss5.bin ss10_v2.25_rom ss20_v2.25_rom)],
         description => "Select BIOS implementation.",
         default => 'seabios',
     },
@@ -2796,6 +2810,7 @@ sub conf_has_audio {
         dev_id => "audiodev$id",
         backend => $audiodriver,
         backend_id => "$audiodriver-backend${id}",
+        server => $audioproperties->{server},
     };
 }
 
@@ -2812,6 +2827,20 @@ sub audio_devs {
 
     if ($audio->{dev} eq 'AC97') {
         push @$devs, '-device', "AC97,id=${id}${audiopciaddr}$audiodev";
+    } elsif ($audio->{dev} eq 'sb16') {
+        push @$devs, '-device', "sb16,id=${id}$audiodev";
+    } elsif ($audio->{dev} eq 'adlib') {
+        push @$devs, '-device', "adlib,id=${id}$audiodev";
+    } elsif ($audio->{dev} eq 'pcspk') {
+        if (min_version($machine_version, 4, 2)) {
+            push @$devs, '-machine', "pcspk-audiodev=$audio->{backend_id}";
+        }
+    } elsif ($audio->{dev} eq 'sb16-adlib-pcspk') {
+        if (min_version($machine_version, 4, 2)) {
+            push @$devs, '-machine', "pcspk-audiodev=$audio->{backend_id}";
+            push @$devs, '-device', "sb16$audiodev";
+            push @$devs, '-device', "adlib$audiodev";
+        }
     } elsif ($audio->{dev} =~ /intel\-hda$/) {
         push @$devs, '-device', "$audio->{dev},id=${id}${audiopciaddr}";
         push @$devs, '-device', "hda-micro,id=${id}-codec0,bus=${id}.0,cad=0$audiodev";
@@ -2820,7 +2849,20 @@ sub audio_devs {
         die "unknown audio device '$audio->{dev}', implement me!";
     }
 
-    push @$devs, '-audiodev', "$audio->{backend},id=$audio->{backend_id}";
+	my $audioOptions = "";
+	if (defined($audio->{server}) && $audio->{server} ne '') {
+		if ($audio->{backend} eq 'pa') {
+			print "-- Using audio backend $audio->{backend} with server $audio->{server}\n";
+			$audioOptions = ",server=$audio->{server}";
+		} else {
+			print "Audio backend: $audio->{backend} not valid for server option\n";
+		}
+	} elsif ($audio->{backend} eq 'pa') {
+		print "Audio backend $audio->{backend} without server value, will attempt to connect via XDG\n";
+		$ENV{XDG_RUNTIME_DIR} = '/run/user/' . $<;
+	}
+
+    push @$devs, '-audiodev', "$audio->{backend},id=$audio->{backend_id}$audioOptions";
 
     return $devs;
 }
@@ -2960,7 +3002,7 @@ sub vga_conf_has_spice {
 # since kvm and tcg machines support different flags
 #
 sub query_supported_cpu_flags {
-    my ($arch) = @_;
+    my ($arch, $conf) = @_;
 
     $arch //= get_host_arch();
     my $default_machine = PVE::QemuServer::Machine::default_machine_for_arch($arch);
@@ -2973,7 +3015,7 @@ sub query_supported_cpu_flags {
         if $arch eq "aarch64";
 
     my $kvm_supported = defined(kvm_version());
-    my $qemu_cmd = PVE::QemuServer::Helpers::get_command_for_arch($arch);
+    my $qemu_cmd = PVE::QemuServer::Helpers::get_command_for_arch($arch, parse_vga($conf->{vga}));
     my $fakevmid = -1;
     my $pidfile = PVE::QemuServer::Helpers::vm_pidfile_name($fakevmid);
 
@@ -3072,7 +3114,7 @@ sub query_understood_cpu_flags {
 my sub should_disable_smm {
     my ($conf, $vga, $machine) = @_;
 
-    return if $machine =~ m/^virt/; # there is no smm flag that could be disabled
+    return if $machine =~ m/^virt/ || $machine =~ m/^SS\-/; # there is no smm flag that could be disabled
 
     return
         (!defined($conf->{bios}) || $conf->{bios} eq 'seabios')
@@ -3145,7 +3187,7 @@ sub config_to_command {
     my $machine_conf = PVE::QemuServer::Machine::parse_machine($conf->{machine});
 
     my $arch = PVE::QemuServer::Helpers::get_vm_arch($conf);
-    my $kvm_binary = PVE::QemuServer::Helpers::get_command_for_arch($arch);
+    my $kvm_binary = PVE::QemuServer::Helpers::get_command_for_arch($arch, parse_vga($conf->{vga}));
     my $kvmver = kvm_user_version($kvm_binary);
 
     if (!$kvmver || $kvmver !~ m/^(\d+)\.(\d+)/ || $1 < 6) {
@@ -3250,9 +3292,13 @@ sub config_to_command {
                 $value =~ s/,/,,/g;
                 $smbios_string .= "," . $key . "=" . $value if $value;
             }
-            push @$cmd, '-smbios', "type=1" . $smbios_string;
+            if ($arch !~ m/^sparc/) {
+                push @$cmd, '-smbios', "type=1" . $smbios_string;
+            }
         } else {
-            push @$cmd, '-smbios', "type=1,$conf->{smbios1}";
+            if ($arch !~ m/^sparc/) {
+                push @$cmd, '-smbios', "type=1,$conf->{smbios1}";
+            }
         }
     }
 
@@ -3273,6 +3319,10 @@ sub config_to_command {
         push $machineFlags->@*, $ovmf_machine_flags->@*;
     }
 
+    if ($conf->{bios} && ($conf->{bios} eq 'ovmf' || $conf->{arch} && $conf->{arch} =~ m/^sparc/)) {
+        push @$cmd, '-bios', "$conf->{bios}";
+    }
+
     if ($q35) { # tell QEMU to load q35 config early
         # we use different pcie-port hardware for qemu >= 4.0 for passthrough
         if (min_version($machine_version, 4, 0)) {
@@ -3291,9 +3341,11 @@ sub config_to_command {
     }
 
     # add usb controllers
+    if ($arch !~ m/^sparc/) {
     my @usbcontrollers =
         PVE::QemuServer::USB::get_usb_controllers($conf, $bridges, $arch, $machine_version);
     push @$devices, @usbcontrollers if @usbcontrollers;
+    }
 
     my ($vga, $qxlnum) = get_vga_properties($conf, $arch, $machine_version, $winversion);
 
@@ -3312,7 +3364,6 @@ sub config_to_command {
     }
 
     my $bootorder = device_bootorder($conf);
-
     # host pci device passthrough
     my ($kvm_off, $gpu_passthrough, $legacy_igd, $pci_devices) =
         PVE::QemuServer::PCI::print_hostpci_devices(
@@ -3403,7 +3454,21 @@ sub config_to_command {
 
     push @$cmd, '-no-reboot' if defined($conf->{reboot}) && $conf->{reboot} == 0;
 
-    if ($vga->{type} && $vga->{type} !~ m/^serial\d+$/ && $vga->{type} ne 'none') {
+    $ENV{DISPLAY} = '';
+	if ($vga->{type} && defined($vga->{server}) && $vga->{server} ne '') {
+		# TODO: gtk/sdl need sdl for 3dfx passthru, should ,gl=on be default?
+		my $displayType = 'gtk';
+		if (defined($vga->{mesa}) && $vga->{mesa} == 1) {
+			$displayType = 'sdl';
+		}
+		print "-- Using $displayType display with $vga->{type} driver and host $vga->{server}\n";
+        push @$cmd, '-vga', $vga->{type};
+		push @$cmd, '-display', $displayType;
+	    # TODO: we can also enable VNC here, not sure if there are drawbacks
+	    #my $socket = PVE::QemuServer::Helpers::vnc_socket($vmid);
+	    #push @$cmd,  '-vnc', "unix:$socket,password=on";
+		$ENV{DISPLAY} = $vga->{server};
+    } elsif ($vga->{type} && $vga->{type} !~ m/^serial\d+$/ && $vga->{type} ne 'none') {
         push @$devices, '-device',
             print_vga_device($conf, $vga, $arch, $machine_version, undef, $qxlnum, $bridges);
 
@@ -3424,6 +3489,7 @@ sub config_to_command {
     push $machineFlags->@*, ($generated->machine_flags() // [])->@*;
     push $rtcFlags->@*, ($generated->rtc_flags() // [])->@*;
 
+    if ($arch !~ m/^sparc/) { # TODO: support specifying cpu type for sparc platforms, until then let the machine use its default
     if ($forcecpu) {
         push @$cmd, '-cpu', $forcecpu;
     } else {
@@ -3432,6 +3498,7 @@ sub config_to_command {
                 $conf, $arch, $kvm, $kvm_off, $machine_version, $winversion, $gpu_passthrough,
             );
     }
+    }
 
     my $virtiofs_enabled = PVE::QemuServer::Virtiofs::virtiofs_enabled($conf);
 
@@ -3615,9 +3682,11 @@ sub config_to_command {
                     $queues = ",num_queues=$drive->{queues}";
                 }
 
+                push @$devices, '-device', "$scsihw_type,id=$controller_prefix$controller$pciaddr$iothread$queues,bus=pciB"
+                if !$scsicontroller->{$controller} && $arch eq 'sparc64';
                 push @$devices, '-device',
                     "$scsihw_type,id=$controller_prefix$controller$pciaddr$iothread$queues"
-                    if !$scsicontroller->{$controller};
+                    if !$scsicontroller->{$controller} && $arch !~ m/^sparc/;
                 $scsicontroller->{$controller} = 1;
             }
 
@@ -3689,7 +3758,12 @@ sub config_to_command {
         $d->{bootindex} = $bootorder->{$netname} if $bootorder->{$netname};
 
         my $netdevfull = print_netdev_full($vmid, $conf, $arch, $d, $netname);
-        push @$devices, '-netdev', $netdevfull;
+        if ($arch eq 'sparc') {
+        	$netdevfull =~ s/net0/lance.0/;
+        	push @$devices, '-net', $netdevfull;
+        } else {
+        	push @$devices, '-netdev', $netdevfull;
+        }
 
         # force +pve1 if machine version 10.0, for host_mtu differentiation
         $version_guard->(10, 0, 1);
@@ -3705,7 +3779,17 @@ sub config_to_command {
             $nets_host_mtu->{$netname},
         );
 
-        push @$devices, '-device', $netdevicefull;
+        if ($arch eq 'sparc') {
+        	# lance is builtin and not pluggable on the sparc platform
+        	push @$devices, '-net', "nic,model=lance,macaddr=08:00:20:b5:09:67"; # TODO: fix static hw
+        } elsif ($arch eq 'sparc64') {
+            # On a real Ultra 5 all PCI devices are attached behind the two simba bridges;
+        	# in-built devices are attached to bus A whilst bus B has 4 free PCI slots for use.
+        	# https://wiki.qemu.org/Documentation/Platforms/SPARC
+            push @$devices, '-device', "$netdevicefull,bus=pciB";
+        } else {
+            push @$devices, '-device', $netdevicefull;
+        }
     }
 
     if ($conf->{ivshmem}) {
@@ -3729,7 +3813,7 @@ sub config_to_command {
     # pci.4 is nested in pci.1
     $bridges->{1} = 1 if $bridges->{4};
 
-    if (!$q35) { # add pci bridges
+    if (!$q35 && $arch !~ m/^sparc/) { # add pci bridges
         if (min_version($machine_version, 2, 3)) {
             $bridges->{1} = 1;
             $bridges->{2} = 1;
@@ -5751,6 +5835,9 @@ sub vm_start_nolock {
                 }
             }
 
+            print "cmd:\n";
+            foreach($cmd) { print join(" ", map { /^-/ ? $_ : "$_ \\\n" } @$_), "\n"; }
+
             my $exitcode = run_command($cmd, %run_params);
             eval { PVE::QemuServer::Virtiofs::close_sockets(@$virtiofs_sockets); };
             log_warn("closing virtiofs sockets failed - $@") if $@;
diff --git a/src/PVE/QemuServer/Drive.pm b/src/PVE/QemuServer/Drive.pm
index c772c803..4bdf79eb 100644
--- a/src/PVE/QemuServer/Drive.pm
+++ b/src/PVE/QemuServer/Drive.pm
@@ -842,7 +842,7 @@ sub parse_drive {
 
     if ($res->{media} && ($res->{media} eq 'cdrom')) {
         return if $res->{snapshot} || $res->{format};
-        return if $res->{interface} eq 'virtio';
+        #return if $res->{interface} eq 'virtio'; // I have no idea why this was disabled in the first place, so I've basically fucked around and later I might find out :)
     }
 
     if (my $size = $res->{size}) {
diff --git a/src/PVE/QemuServer/DriveDevice.pm b/src/PVE/QemuServer/DriveDevice.pm
index ca230ed3..7f79699b 100644
--- a/src/PVE/QemuServer/DriveDevice.pm
+++ b/src/PVE/QemuServer/DriveDevice.pm
@@ -68,7 +68,9 @@ sub print_drivedevice_full {
         my $device_type =
             PVE::QemuServer::Drive::get_scsi_device_type($drive, $storecfg, $machine_version);
 
-        if (!$conf->{scsihw} || $conf->{scsihw} =~ m/^lsi/ || $conf->{scsihw} eq 'pvscsi') {
+        if ($arch eq 'sparc') {
+            $device = "scsi-$device_type,channel=0,scsi-id=$unit,lun=0";
+        } elsif (!$conf->{scsihw} || $conf->{scsihw} =~ m/^lsi/ || $conf->{scsihw} eq 'pvscsi') {
             $device = "scsi-$device_type,bus=$controller_prefix$controller.0,scsi-id=$unit";
         } else {
             $device = "scsi-$device_type,bus=$controller_prefix$controller.0,channel=0,scsi-id=0"
@@ -182,6 +184,10 @@ sub print_drivedevice_full {
         }
     }
 
+    if ($arch =~ m/^sparc/ && $drive->{media} && $drive->{media} eq 'cdrom') {
+        $device .= ",physical_block_size=512";
+    }
+
     return $device;
 }
 
diff --git a/src/PVE/QemuServer/Helpers.pm b/src/PVE/QemuServer/Helpers.pm
index 35c00754..879cb480 100644
--- a/src/PVE/QemuServer/Helpers.pm
+++ b/src/PVE/QemuServer/Helpers.pm
@@ -25,12 +25,15 @@ our @EXPORT_OK = qw(
 my $nodename = PVE::INotify::nodename();
 
 my $arch_to_qemu_binary = {
+    sparc => '/usr/bin/qemu-system-sparc',
+    sparc64 => '/usr/bin/qemu-system-sparc64',
     aarch64 => '/usr/bin/qemu-system-aarch64',
     x86_64 => '/usr/bin/qemu-system-x86_64',
 };
 
-sub get_command_for_arch($) {
-    my ($arch) = @_;
+sub get_command_for_arch($$) {
+    my ($arch, $vga) = @_;
+    return '/usr/bin/qemu-system-x86_64-3dfx' if get_host_arch() eq $arch && $vga->{mesa} == 1;
     return '/usr/bin/kvm' if get_host_arch() eq $arch; # i.e. native arch
 
     my $cmd = $arch_to_qemu_binary->{$arch}
@@ -49,8 +52,13 @@ my $kvm_mtime = {};
 sub kvm_user_version {
     my ($binary) = @_;
 
-    $binary //= get_command_for_arch(get_host_arch()); # get the native arch by default
-    my $st = stat($binary);
+    my $hardcoded_vga_no_mesa = {
+        mesa => 0,
+    };
+
+    $binary //= get_command_for_arch(get_host_arch(), $hardcoded_vga_no_mesa); # get the native arch by default
+    my $st = stat($binary)
+    or die "unable to stat file '$binary' - $!\n"; # most likely one of the additional binaries provided by the wsh patches have failed to build and are missing from the debian package
 
     my $cachedmtime = $kvm_mtime->{$binary} // -1;
     return $kvm_user_version->{$binary}
diff --git a/src/PVE/QemuServer/Machine.pm b/src/PVE/QemuServer/Machine.pm
index c60ab477..c5380822 100644
--- a/src/PVE/QemuServer/Machine.pm
+++ b/src/PVE/QemuServer/Machine.pm
@@ -51,7 +51,7 @@ my $machine_fmt = {
         description => "Specifies the QEMU machine type.",
         type => 'string',
         pattern =>
-            '(pc|pc(-i440fx)?-\d+(\.\d+)+(\+pve\d+)?(\.pxe)?|q35|pc-q35-\d+(\.\d+)+(\+pve\d+)?(\.pxe)?|virt(?:-\d+(\.\d+)+)?(\+pve\d+)?)',
+            '(pc|pc(-i440fx)?-\d+(\.\d+)+(\+pve\d+)?(\.pxe)?|q35|pc-q35-\d+(\.\d+)+(\+pve\d+)?(\.pxe)?|virt(?:-\d+(\.\d+)+)?(\+pve\d+)?|sun4[a-z]{1}|SS-\d{1,2})',
         maxLength => 40,
         format_description => 'machine type',
         optional => 1,
@@ -315,18 +315,15 @@ sub get_machine_pve_revisions {
         return $PVE_MACHINE_VERSION->{$1};
     }
 
-    die "internal error: cannot get pve version for invalid string '$machine_version_str'";
+    return;  # return undef for invalid version strings
 }
 
 sub get_pve_version {
     my ($verstr) = @_;
 
-    if (my $pve_machine = get_machine_pve_revisions($verstr)) {
-        return $pve_machine->{highest}
-            || die "internal error - machine version '$verstr' missing 'highest'";
-    }
-
-    return 0;
+    my $pve_machine = get_machine_pve_revisions($verstr);
+    return 0 if !$pve_machine;  # return 0 for invalid/unknown versions
+    return $pve_machine->{highest} || 0;  # return 0 if highest is not set
 }
 
 sub can_run_pve_machine_version {
diff --git a/src/PVE/QemuServer/Network.pm b/src/PVE/QemuServer/Network.pm
index eb8222e8..20be752a 100644
--- a/src/PVE/QemuServer/Network.pm
+++ b/src/PVE/QemuServer/Network.pm
@@ -28,6 +28,8 @@ my $nic_model_list = [
     'rtl8139',
     'virtio',
     'vmxnet3',
+    'sunhme',
+    'lance',
 ];
 
 my $net_fmt_bridge_descr = <<__EOD__;
diff --git a/src/PVE/QemuServer/PCI.pm b/src/PVE/QemuServer/PCI.pm
index c9cf8de0..cfa535fb 100644
--- a/src/PVE/QemuServer/PCI.pm
+++ b/src/PVE/QemuServer/PCI.pm
@@ -303,6 +303,11 @@ sub print_pci_addr {
 
     my $res = '';
 
+    if ($arch =~ m/^sparc/) {
+      print "sparc/sparc64 does not support PCI devices, ignoring: $id\n";
+      return $res;
+    }
+
     my $map = get_pci_addr_map();
     if (my $d = $get_addr_mapping_from_id->($map, $id)) {
         # Using same bus slots on all HW, so we need to check special cases here. For aarch64, the
diff --git a/src/PVE/QemuServer/USB.pm b/src/PVE/QemuServer/USB.pm
index c9408a42..3450c27c 100644
--- a/src/PVE/QemuServer/USB.pm
+++ b/src/PVE/QemuServer/USB.pm
@@ -136,6 +136,8 @@ sub get_usb_controllers {
     if ($arch eq 'aarch64') {
         $pciaddr = print_pci_addr('ehci', $bridges, $arch);
         push @$devices, '-device', "usb-ehci,id=ehci$pciaddr";
+    } elsif ($arch =~ m/^sparc/) {
+        print "USB disabled for sparc/sparc64\n";
     } elsif (!$is_q35) {
         $pciaddr = print_pci_addr("piix3", $bridges, $arch);
         push @$devices, '-device', "piix3-usb-uhci,id=uhci$pciaddr.0x2";
@@ -152,7 +154,7 @@ sub get_usb_controllers {
         $use_usb2 = 1 if !$d->{usb3};
     }
 
-    if (!$use_qemu_xhci && !$is_q35 && $use_usb2 && $arch ne 'aarch64') {
+    if (!$use_qemu_xhci && !$is_q35 && $use_usb2 && $arch ne 'aarch64' && $arch !~ m/^sparc/) {
         # include usb device config if still on x86 before-xhci machines and if USB 3 is not used
         push @$devices, '-readconfig', '/usr/share/qemu-server/pve-usb.cfg';
     }
